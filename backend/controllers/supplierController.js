import supplierModel from "../models/supplierModel.js";
import asyncHandler from "express-async-handler";
import { transporter } from "../config/transporter.js";
import jwt from "jsonwebtoken";
import bcryptjs from "bcryptjs";
// Get
const getAllSupplier = asyncHandler(async (req, res) => {
  try {
    const suppliers = await supplierModel
      .find()
      .populate("materialSupplied")
      .populate({
        path: "purchaseOrders",
        select: "purchaseOrderNumber items totalAmount paymentTerm",
      });

    res.json(suppliers);
  } catch (error) {
    res.status(500).json({ error: err.message });
  }
});

const getSupplierById = asyncHandler(async (req, res) => {
  try {
    const supplier = await supplierModel.findById(req.params.id);
    // .populate('materialsSupplied');
    if (!supplier) {
      return res.status(400).json({ errors: "Supplier not found" });
    }
    res.status(200).json(supplier);
  } catch (error) {
    res.status(500).json({ error: err.message });
  }
});

// Create
const createSupplier = asyncHandler(async (req, res) => {
  const {
    supplierName,
    // supplierCode,
    contactPerson,
    contactEmail,
    contactPhone,
    // New
    // address,
    street,
    city,
    state,
    zipCode,
    country,
    paymentTerms,
    materialSupplied,
    rating,
    email,
    password,
    supplierType,
    // materialsSupplied,
  } = req.body;

  const newSupplier = new supplierModel({
    supplierName: supplierName,
    // supplierCode: supplierCode,
    contactPerson: contactPerson,
    contactEmail: contactEmail,
    contactPhone: contactPhone,
    address: {
      street,
      city,
      state,
      zipCode,
      country,
    },

    paymentTerms: paymentTerms,
    rating: rating,
    materialSupplied: materialSupplied,
    email: email,
    password: password,
    supplierType: supplierType,
  });

  try {
    const saveSuppliers = await newSupplier.save();
    res.status(201).json(saveSuppliers);
  } catch (err) {
    res.status(400).json({ errors: err.message });
  }
});

// Update
const updateSupplier = asyncHandler(async (req, res) => {
  const myBody = req.body;
  const { id } = req.params;

  try {
    const updatedSupplier = await supplierModel.findByIdAndUpdate(id, myBody, {
      new: true,
    });

    if (!updatedSupplier)
      return res.status(400).json({ message: "Supplier not found" });

    res.json(updatedSupplier);
  } catch (error) {
    res.status(400).json({ error: error.messages });
  }
});

// Supplier Delete
const deleteSupplier = asyncHandler(async (req, res) => {
  const { id } = req.params;
  const supplier = await supplierModel.findByIdAndDelete(id);

  if (!supplier) {
    return res
      .status(400)
      .json({ success: false, message: "Supplier Not Found" });
  }

  res
    .status(200)
    .json({ success: true, message: `"Deleted Successfully!"${id}` });
});

// COMPLETE Registration
// COMPLETE Registration
const completeRegistration = asyncHandler(async (req, res) => {
  const {
    email, // Include email for finding the supplier
    supplierName,
    contactPerson,
    contactEmail,
    contactPhone,
    street,
    city,
    state,
    zipCode,
    country,
    paymentTerms,
  } = req.body;

  // Ensure required fields are provided
  if (
    !email ||
    !supplierName ||
    !contactPerson ||
    !contactEmail ||
    !contactPhone ||
    !street ||
    !city ||
    !state ||
    !zipCode ||
    !country ||
    !paymentTerms
  ) {
    return res.status(400).json({ error: "All fields are required." });
  }

  // Find the supplier by email
  const supplier = await supplierModel.findOne({ email });

  if (!supplier) {
    return res.status(404).json({ error: "Supplier not found." });
  }

  if (supplier.status !== "Pending") {
    return res
      .status(400)
      .json({ error: "Supplier account is not pending verification." });
  }

  // Prepare the data to update
  const updatedData = {
    supplierName,
    contactPerson,
    contactEmail,
    contactPhone,
    address: {
      street,
      city,
      state,
      zipCode,
      country,
    },
    paymentTerms,
  };

  // Update supplier details and activate the account
  Object.assign(supplier, updatedData);
  // Object.assign(supplier, updatedData, { status: "Active" });

  // Save the updated supplier (supplierCode will be generated by pre-save hook)
  await supplier.save();

  res.status(200).json({
    message: "Supplier details updated successfully and account activated.",
    supplier,
  });
});

const sendApprovalEmail = asyncHandler(async (supplier, password) => {
  const mailOptions = {
    from: "JJM Manufacturing <mtrcb32130@gmail.com>", // Sender
    to: supplier.email, // Supplier email
    subject: "Your Supplier Account has been Approved",
    html: `
      <p>Dear ${supplier.contactPerson},</p>
      <p>Your supplier account has been approved. Below are your login credentials:</p>
      <p><strong>Email:</strong> ${supplier.email}</p>
      <p><strong>Password:</strong> ${password}</p>
      <p>Please log in to your account and update your details if necessary:</p>
      <a href="https://manufacturing-logistic1-client-frontend.onrender.com/login">Login here</a>
      <p>Best regards,</p>
      <p>Your Company Team</p>
    `,
  };

  await transporter.sendMail(mailOptions);
});

const approveSupplier = asyncHandler(async (req, res) => {
  const { id } = req.params;

  const supplier = await supplierModel.findById(id);

  if (!supplier) {
    return res
      .status(404)
      .json({ success: false, message: "Supplier not found" });
  }

  // Generate a random password if it doesn't exist
  let password = supplier.password;
  if (!password) {
    password = Math.random().toString(36).slice(-8); // Generate random 8-character password

    // Hash the password before saving it
    const salt = await bcryptjs.genSalt(10);
    supplier.password = await bcryptjs.hash(password, salt);
  }

  supplier.status = "Active";
  await supplier.save();

  // Send an email with login credentials
  await sendApprovalEmail(supplier, password);

  res.status(200).json({
    success: true,
    message: "Supplier approved successfully",
    supplier,
  });
});

// Reject supplier
const deactivatedSupplier = asyncHandler(async (req, res) => {
  const { id } = req.params;
  const supplier = await supplierModel.findById(id);
  if (!supplier) {
    return res
      .status(404)
      .json({ success: false, message: "Supplier not found" });
  }

  supplier.status = "Deactivated";

  await supplier.save();

  res.status(200).json({ success: true, message: "Deactivated successfully!" });
});

const loginSupplier = asyncHandler(async (req, res) => {
  const { email, password } = req.body;

  // Find user by email
  const user = await supplierModel.findOne({ email });

  if (user.status === "Deactivated") {
    return res.status(400).json({
      success: false,
      message:
        "Your account has been deactivated. Please contact the logistics team for assistance.",
    });
  }
  // If user doesn't exist or password is incorrect
  if (!user || !(await user.matchPassword(password))) {
    return res.status(400).json({
      success: false,
      message: "Invalid email or password",
    });
  }

  // If user exists and password matches
  res.status(200).json({
    success: true,
    message: "Login successful",
    token: createToken(user._id),
  });
});

const createToken = (id) => {
  return jwt.sign({ id }, process.env.JWT_SECRET);
};

const getSearch = asyncHandler(async (req, res) => {
  const keyword = req.query.search
    ? {
        $or: [
          { name: { $regex: req.query.search, $option: "i" } },
          { email: { $regex: req.query.search, $option: "i" } },
          { role: { $regex: req.query.search, $option: "i" } },
        ],
      }
    : {};

  const users = await supplierModel
    .find(keyword)
    .find({ _id: { $ne: req._id } });

  res.status(200).json(users);
});

export {
  getAllSupplier,
  getSupplierById,
  createSupplier,
  updateSupplier,
  deleteSupplier,
  completeRegistration,
  approveSupplier,
  deactivatedSupplier,
  loginSupplier,
  getSearch,
};
